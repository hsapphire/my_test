# redis
 读写锁,持久化的两种rdb,缓存击穿，穿透，雪崩。分布式锁，
 ## 缓存雪崩
 定义：缓存雪崩是指系统中的缓存同时失效（或者缓存服务挂掉），导致大量的请求直接访问数据库，给数据库带来巨大的压力，可能会导致数据库宕机或性能瓶颈。
原因：缓存失效时间相同：如果大量缓存的过期时间设置相同，且缓存服务不可用时，所有请求都会直接打到数据库，导致瞬间大量的数据库请求。
缓存服务器宕机：缓存服务器本身出现故障，导致所有缓存无法访问。
解决方案：缓存过期时间随机化：为不同的缓存设置不同的过期时间，避免所有缓存同时失效。例如，通过在过期时间基础上加一个随机值。
long expireTime = baseExpireTime + (Math.random() * randomFactor);
使用多级缓存：采用本地缓存（如 Guava）和分布式缓存（如 Redis）的结合，当一级缓存失效时可以尝试从二级缓存中获取数据，减轻数据库的负载。
增加缓存的过期时间：合理设置缓存的过期时间，避免频繁的缓存更新带来过大的数据库压力。
降级处理：当缓存不可用时，应用可以暂时关闭缓存，或者使用熔断器（如 Hystrix）来防止大量请求打到数据库。
## 缓存穿透 (Cache Penetration)

定义：缓存穿透是指查询的数据在缓存和数据库中都不存在，导致每次请求都会访问数据库，形成缓存穿透。攻击者通常通过构造恶意请求，使得每次请求都绕过缓存直接查询数据库。
原因：请求的数据在数据库和缓存中都不存在，导致每次请求都直接查询数据库，增加数据库的压力。
常见的如恶意用户通过构造无效的请求（如非法 ID 或不存在的记录）来绕过缓存查询数据库。
解决方案：缓存空对象：当缓存查询不到数据时，可以将 "空值"（如 null 或特殊的标记值）存入缓存，并为其设置短期的过期时间，这样相同的无效请求会被缓存，避免每次都查询数据库。
cache.set("key", null, CACHE_NULL_TTL);
使用布隆过滤器：布隆过滤器是一种空间效率极高的数据结构，可以用来判断某个请求是否存在于数据库中。通过布隆过滤器预先过滤掉无效请求，避免请求到达数据库。
if (!bloomFilter.mightContain(queryKey)) {
    return;  // 请求数据不存在，直接返回
}
校验参数合法性：在应用层加验证，对传入的请求参数进行合法性检查（如 ID 是否存在、格式是否正确），从源头上减少不必要的查询。
## 缓存击穿 (Cache Breakdown)

定义：缓存击穿是指某个热点数据的缓存失效，而在该数据频繁被访问时，由于缓存失效，所有请求都会直接访问数据库，导致数据库瞬间承受巨大的压力。不同于缓存雪崩，缓存击穿通常是由于单个热点数据的缓存失效引起的。

原因：热点数据的缓存失效：某些数据在业务中非常常见，缓存失效后所有请求会集中到数据库，导致数据库压力增大。

数据过期或未及时更新：热点数据在缓存中失效后，多个请求会同时去访问数据库，给数据库带来压力。

解决方案：加锁机制：使用互斥锁（如 mutex、Redis 中的 SETNX）确保只有第一个请求会去加载数据，其他请求可以等待第一个请求完成后，直接从缓存中获取数据。

if (lock.acquireLock("hotspotKey")) {
    // Load data from DB and set cache
} else {
    // Wait for lock to release, then get from cache
}


使用双重检查机制：为了避免缓存击穿带来的性能问题，可以使用双重检查机制。首先检查缓存，如果缓存失效，则加锁进行数据加载，再次检查缓存是否已经被其他线程填充。

if (cache.contains(key)) {
    return cache.get(key);
}

synchronized (key) {
    if (!cache.contains(key)) {
        // Load data from DB and set cache
    }
}


提前预加载缓存：可以在缓存失效前，提前预加载热点数据缓存，确保热点数据的高可用性，避免高并发请求时造成数据库负担。
# spring cloud
nacos: 发现与注册实现原理
load banlance:
sentinal:限流实现原理，
spring boot: 自动装配实现原理，

# arraylist 的add set 实现原理

# hashcode的实现原理

# mysql 
读写锁，
索引的实现原理

# java

# k8s docker


简历
添加数据治理方面的经验。
