public class DeadlockDemo {

    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public static void main(String[] args) {

        Thread t1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Thread 1: holding lock1...");
                try { Thread.sleep(100); } catch (InterruptedException ignored) {}

                System.out.println("Thread 1: waiting for lock2...");
                synchronized (lock2) {
                    System.out.println("Thread 1: holding lock1 and lock2...");
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("Thread 2: holding lock2...");
                try { Thread.sleep(100); } catch (InterruptedException ignored) {}

                System.out.println("Thread 2: waiting for lock1...");
                synchronized (lock1) {
                    System.out.println("Thread 2: holding lock2 and lock1...");
                }
            }
        });

        t1.start();
        t2.start();
    }
}

死锁发生的条件：
线程1持有 lock1，等待 lock2。

线程2持有 lock2，等待 lock1。

两个线程都不释放锁，进入互相等待状态，形成死锁。
如何观察死锁：
你可以运行这个程序后使用以下命令观察死锁：

jps                         # 找到 Java 进程 ID
jstack <pid>                # 查看线程堆栈
你会看到类似如下的输出（简化）：

csharp
Copy
Edit
Found one Java-level deadlock:
"Thread-1":
  waiting to lock monitor 0x00007fcd8c02a2b0 (object lock1),
  which is held by "Thread-0"
"Thread-0":
  waiting to lock monitor 0x00007fcd8c02a3c0 (object lock2),
  which is held by "Thread-1"

  

  敛侭掘 6
榟涖滨6
16PRO權堪爵噫28黑6200日6200原6300金6300
膈的车上6PRO256黑7630日7530原7630金7680
妙国6PR0 512黑9350日9350原9150金9350
暦为6PRO 1TB黑自原金
16MAX256黑8620日8660原8620金8620
刳调电更 廑芏取MAX512黑9500日9900原9600金9450
16MAX 1TB黑自原金