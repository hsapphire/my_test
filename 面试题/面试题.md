jps、jstat、jmap、jstack 等
jps               # 显示 Java 进程 ID 和主类名
jps -v            # 显示进程的 JVM 参数
jps -l            # 显示主类的完整路径或 Jar 包名


jstat（JVM Statistics Monitoring Tool）
作用：查看 JVM 的各种运行状态，如垃圾回收（GC）情况、类加载信息、内存使用情况等。
jstat -gc <pid> 1000  # 每秒输出一次 GC 状态
jstat -class <pid>    # 查看类加载信息
jstat -gcutil <pid>   # 显示各个内存区域的使用率


3. jmap（Memory Map Tool）
作用：生成堆转储（heap dump），查看堆内对象信息。

常用命令：
jmap -dump:format=b,file=heapdump.hprof <pid>  # 导出 heap dump
jmap -histo <pid>      # 按实例数/内存大小列出堆中的对象
jmap -heap <pid>       # 查看堆的摘要信息（GC 使用情况）

4. jstack（Stack Trace Tool）
作用：导出 Java 线程的堆栈快照，常用于排查死锁、线程阻塞等问题。

常用命令：

jstack <pid>              # 打印线程栈信息
jstack -l <pid>           # 显示锁信息（推荐）
jstack -F <pid>           # 强制打印（当普通命令失败时）
🔧 使用建议
排查 内存泄漏：使用 jmap -histo 和 jmap -dump。

分析 GC 问题：结合 jstat -gc、jmap -heap。

解决 线程死锁/卡顿：配合 jstack 和 top 工具。

查找 Java 程序 PID：先用 jps，然后根据 PID 调用其他命令。

2.
select  a.id from  a where a.id not in (select b.id from b);
select a.id from a left join b on a.id=b.id where b.id is null;

1. 单例设计模式
   public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

1. spring cloud 为什么要有熔断
   如果服务C挂了或响应很慢，而服务B不停地去调用它：

服务B的线程会被阻塞（等待服务C）
线程池慢慢被占满
服务A调用服务B也被拖慢，逐层传播
整个系统连健康的服务都响应变慢
最终可能全部挂掉（这就是“雪崩效应”）
熔断器就像电路中的保险丝，在检测到下游服务异常（高错误率、超时等）时，会临时“断开”调用，从而保护上游服务：

5. mysql 10万条数据，要做一个下载 。怎么怎么做。 
    推荐做法：Java 后台异步导出 + CSV 文件
  步骤：
  前端点击“导出” → 发起请求
  后端创建异步任务，后台查询 MySQL 并生成 CSV 文件
  任务完成后返回下载链接（比如上传 OSS、本地服务器等）
  用户查看下载中心或通知中心，点击链接下载

@GetMapping("/export")
public void export(HttpServletResponse response) throws IOException {
    // 设置响应头
    response.setContentType("text/csv");
    response.setHeader("Content-Disposition", "attachment;filename=data.csv");
    PrintWriter writer = response.getWriter();
    // 写入表头
    writer.println("ID,Name,Email");
    // 分批查询数据
    int pageSize = 1000;
    for (int i = 0; i < 100; i++) {
        List<User> users = userService.getPage(i, pageSize);
        for (User user : users) {
            writer.printf("%d,%s,%s%n", user.getId(), user.getName(), user.getEmail());
        }
    }

    writer.flush();
    writer.close();
}
6. mysql 事物隔离级别
  每种隔离级别详解
  1. READ UNCOMMITTED（读未提交）
  最低级别，允许读取未提交数据（脏读）
  用得少，几乎无数据一致性保障，但性能极高

  2. READ COMMITTED（读已提交）✅ Oracle 默认
  每次查询都能读到别的事务“已提交”的数据

  避免脏读，但可能出现不可重复读、幻读

  3. REPEATABLE READ（可重复读）✅ MySQL 默认
  在同一个事务中，多次读取结果一致（使用快照读）

  避免不可重复读，但仍可能出现幻读（行数变化）

  4. SERIALIZABLE（串行化）
  最严格，事务串行执行（加读写锁）
  防止所有并发问题，但性能最差

7. a,b两个表， id，a表：1-10，b表：2，4，6，8，10，写sql得出1,3,5,7,9
  SELECT id
  FROM a
  WHERE id NOT IN (SELECT id FROM b);

  SELECT a.id
  FROM a
  LEFT JOIN b ON a.id = b.id
  WHERE b.id IS NULL;

8.

特性	ArrayList	LinkedList
底层结构	动态数组（数组）	双向链表
插入/删除效率	慢（中间插入或删除需移动元素）	快（只修改节点指针）
随机访问	快（索引访问为 O(1)）	慢（需要从头或尾遍历到目标位置）
内存占用	相对少（仅存储数据）	相对高（存储数据 + 前后指针）
插入到末尾	快，平均 O(1)，偶尔扩容成本 O(n)	快，O(1)
插入到中间	慢，O(n)（需要移动元素）	较快，O(1) 修改指针 + O(n) 找位置
线程安全	否	否

9. hash冲突如何解决

10.自动装配的原理
autoconfig，bean对象，

11. mysql索引
索引分类：jucu ,not jucu
优化sql事情:
    重复sql，with提出，减少子查询。
    explain分析sql执行计划
    数据量大的时候，分库分表，分区按7天一分区

12. redis
常用的数据结构，set（去重） , hset, zset .string ,list（先进先出）
互拆锁：分布式的。
zset

13. 设计模式
单例，
1.  生产出现问题如何排查的。
空指针 排查的步骤，看日志-看第几天排的错。
2. 如何学习新的技术 
   1. 找教程，代码搞下来，跑一下。
   2. kafka 中间件，可能会有什么问题，分布式可能会有什么问题。
3.  并发的场景
4. 不写日报是最好的。
5. 

# 技术栈
大数据，hive,spark, hadoop ,starrocks, kafka,rabitmq



1.性格不急躁。
2.
